<html>
<head>
<title>Calzon</title>
</head>
<body marginheight="0" marginwidth="0" bgcolor="blue">

<canvas id="webgl-canvas" style="border: none; width:100%; height: 100%" width="100" height="100">
</canvas>

<script>
	"use strict";
	var canvas = document.getElementById("webgl-canvas");
	canvas.width = canvas.clientWidth; 
	canvas.height = canvas.clientHeight;
	var aspect = canvas.width / canvas.height;
	var gl = canvas.getContext("experimental-webgl");
	gl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
	gl.clearColor(0, 0, 0, 1);
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR);
	gl.blendEquation(gl.FUNC_ADD);
	gl.disable(gl.DEPTH_TEST);
    gl.depthMask(false);
	
	function getShader(type, text) {
		var shader = gl.createShader(type);
		gl.shaderSource(shader, text);
		gl.compileShader(shader);
		if( ! gl.getShaderParameter(shader, gl.COMPILE_STATUS) )
			throw gl.getShaderInfoLog(shader);
		return shader;
	}

	var vertexShader = "attribute vec3 vertexPosition;"+
					   "attribute vec3 color;"+
					   "varying vec3 vColor;"+
					   "void main(void) {"+
					   "  gl_Position = vec4(vertexPosition, 1.0);"+
					   "  gl_Position.x /= " + aspect + ";"+
					   "  gl_PointSize = 6.0;"+
					   "  vColor = color;"+
					   "}";
	
	var fragmentShader = "precision mediump float;"+
						 "varying vec3 vColor;"+
						 "void main(void) {"+
						 "  vec2 uv = 2.0 * gl_PointCoord - 1.0;"+
						 "  float r = 1.0-(uv.x * uv.x + uv.y * uv.y);"+
						 "  gl_FragColor = vec4(vec3(r)*vColor,1.0);"+
						 "}";
	
	var shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram, getShader( gl.VERTEX_SHADER, vertexShader));
	gl.attachShader(shaderProgram, getShader( gl.FRAGMENT_SHADER, fragmentShader));
	gl.linkProgram(shaderProgram);
	gl.useProgram(shaderProgram);

	var vpLoc = gl.getAttribLocation(shaderProgram, "vertexPosition");
	gl.enableVertexAttribArray(vpLoc);

	var cLoc = gl.getAttribLocation(shaderProgram, "color");
	gl.enableVertexAttribArray(cLoc);
	
	var players = [{
			color: [0.8,0.8,0.8]; // neutral
		},{
			color: [0,0,1]; // human
		},{
			color: [1,0,0]; // computer 1
		},{
			color: [0,1,0]; // computer 2
	}];
	
	var planets = [
		{ pos: [0,0], owner: players[0]}, 
		{ pos: [0.5,0.5], owner: players[1]}, 
		{ pos: [-0.5,-0.5], owner: players[2]}, 
		{ pos: [-0.5,0.5], owner: players[3]}, 
		{ pos: [0.5,-0.5], owner: players[0]}
	];
	
	var particleCount = 2000;
	var p = { v:new Float32Array(particleCount*3), m:[], a:[], planet:[], player:[], c:new Float32Array(particleCount*3), vb : gl.createBuffer(), cb : gl.createBuffer() };
	for ( var i = 0; i < particleCount; i++) {
		p.v[i*3+0] = Math.random()*2 - 1; // vertices
		p.v[i*3+1] = Math.random()*2 - 1;
		p.v[i*3+2] = 0;
		p.m[i*2+0] = 0; // movement vector
		p.m[i*2+1] = 0;
		p.a[i*2+0] = 0; // acceleration vector
		p.a[i*2+1] = 0;
		p.planet[i] = Math.floor(Math.random() * (planets.length/2+1)); // assigned planet 
		p.player[i] = p.planet[i].owner; // assigned player 
		p.c[i*3+0] = p.player[i].color[0];
		p.c[i*3+1] = p.player[i].color[1];
		p.c[i*3+2] = p.player[i].color[2];
	}
	
	function drawScene(elapsed) {
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		gl.bindBuffer( gl.ARRAY_BUFFER, p.vb);
		gl.bufferData( gl.ARRAY_BUFFER, p.v, gl.DYNAMIC_DRAW);
		gl.vertexAttribPointer( vpLoc, 3, gl.FLOAT, false, 0, 0);

		gl.bindBuffer( gl.ARRAY_BUFFER, p.cb);
		gl.bufferData( gl.ARRAY_BUFFER, p.c, gl.DYNAMIC_DRAW);
		gl.vertexAttribPointer( cLoc, 3, gl.FLOAT, false, 0, 0);

		gl.drawArrays( gl.POINTS, 0, particleCount);
	}

	function vecLen2DSquared(arr,pos) {
		var a = arr[pos*2+0];
		var b = arr[pos*2+1];
		return a*a+b*b;
	}

	function vecLen2D(arr,pos) {
		var a = arr[pos*2+0];
		var b = arr[pos*2+1];
		return Math.sqrt(a*a+b*b);
	}

	function normalize2D( arr, pos, factor) {
		var lengthInv = factor/vecLen2D(arr, pos);
		arr[pos*2+0] *= lengthInv;
		arr[pos*2+1] *= lengthInv;
	}
	
	var lastTime=0;
	function tick( timeNow) {
		var elapsed = timeNow - lastTime;
		lastTime = timeNow;
		if(isNaN(elapsed)) elapsed = 0;
		requestAnimationFrame(tick);
		var e = timeNow/1000;
		for ( var i = 0; i < particleCount; i++) {
			p.v[i*3+0] += p.m[i*2+0]; // add the movement vector to the current position
			p.v[i*3+1] += p.m[i*2+1];
			
			p.a[i*2+0] = planets[p.p[i]*2+0] - p.v[i*3+0]; // set the accel vector to the direction of the planet
			p.a[i*2+1] = planets[p.p[i]*2+1] - p.v[i*3+1];
			
			normalize2D(p.a,i,0.00002); // normalize it

			p.m[i*2+0] += p.a[i*2+0]; // set the movement vector 
			p.m[i*2+1] += p.a[i*2+1];
			
			if(vecLen2DSquared(p.m,i)>0.002*0.002) { // clamp the movement vector
				normalize2D(p.m,i, 0.002);
			}
		}
		drawScene(e);
	}
	
	console.log( 'error: ' + gl.getError());
	requestAnimationFrame(tick);
	
	function distance(x1, y1, x2, y2) {
		var x = x2 - x1,
			y = y2 - y1;
		return Math.sqrt(x*x + y*y);
	};
	
	
	var closestPlanet = 0;
	var closestPlanet2 = 0;

	canvas.addEventListener('mousedown', function(e){
		var x = (e.clientX/canvas.width)*2-1;
		var y = -((e.clientY/canvas.height)*2-1);
		
		var lastDistance = 10000;
		for ( var i = 0; i < planets.length/2; i++) {
			var px = planets[i*2+0];
			var py = planets[i*2+1];
			var d = distance( x, y, px, py);
			if( d < lastDistance) {
				lastDistance = d;
				closestPlanet = i;
			}
		}
		// set all particles close the the selected planet to white
		for ( var i = 0; i < particleCount; i++) {
			if( p.p[i] == closestPlanet ) {
				p.c[i*3+0] = 1;
				p.c[i*3+1] = 1;
				p.c[i*3+2] = 1;
			}
		}

		
	});
	canvas.addEventListener('mouseup', function(e){
		var x = (e.clientX/canvas.width)*2-1;
		var y = -((e.clientY/canvas.height)*2-1);
		
		var lastDistance = 10000;
		for ( var i = 0; i < planets.length/2; i++) {
			var px = planets[i*2+0];
			var py = planets[i*2+1];
			var d = distance( x, y, px, py);
			if( d < lastDistance) {
				lastDistance = d;
				closestPlanet2 = i;
			}
		}
		// set all particles close the the selected planet to white
		for ( var i = 0; i < particleCount; i++) {
			if( p.p[i] == closestPlanet ) {
				p.c[i*3+0] = 1;
				p.c[i*3+1] = 1;
				p.c[i*3+2] = 1;
			}
		}

		
	});


</script>


</body>
</html>
